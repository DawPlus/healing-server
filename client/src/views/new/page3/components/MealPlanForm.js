import React, { useState, useEffect } from 'react';
import {
  Paper,
  Typography,
  Box,
  TextField,
  Button,
  IconButton,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  Alert,
  FormControlLabel,
  Radio,
  RadioGroup,
  InputAdornment,
  Tooltip
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ko } from 'date-fns/locale';
import moment from 'moment';
import Swal from 'sweetalert2';

// Icons
import RestaurantIcon from '@mui/icons-material/Restaurant';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EventIcon from '@mui/icons-material/Event';
import PeopleIcon from '@mui/icons-material/People';
import MenuBookIcon from '@mui/icons-material/MenuBook';
import BreakfastDiningIcon from '@mui/icons-material/BreakfastDining';
import LunchDiningIcon from '@mui/icons-material/LunchDining';
import DinnerDiningIcon from '@mui/icons-material/DinnerDining';
import EditIcon from '@mui/icons-material/Edit';
import SaveIcon from '@mui/icons-material/Save';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import CloseIcon from '@mui/icons-material/Close';

// 6 fixed meal types based on the requirements
const mealTypes = [
  { value: 'breakfast', label: '조식', icon: <BreakfastDiningIcon fontSize="small" />, price: 8800, ingredient: 6000 },
  { value: 'lunch_regular', label: '중식(일반)', icon: <LunchDiningIcon fontSize="small" />, price: 12000, ingredient: 6000 },
  { value: 'lunch_box', label: '도시락 중식', icon: <LunchDiningIcon fontSize="small" />, price: 15000, ingredient: 10000 },
  { value: 'dinner_regular', label: '석식(일반)', icon: <DinnerDiningIcon fontSize="small" />, price: 12000, ingredient: 6000 },
  { value: 'dinner_special_a', label: '석식(특식A)', icon: <DinnerDiningIcon fontSize="small" />, price: 20000, ingredient: 10000 },
  { value: 'dinner_special_b', label: '석식(특식B)', icon: <DinnerDiningIcon fontSize="small" />, price: 25000, ingredient: 13000 }
];

// Mapping meal types to database types (UI → DB)
const mealTypeToDbType = {
  'breakfast': 'breakfast',
  'lunch_regular': 'lunch',
  'lunch_box': 'lunch_box',
  'dinner_regular': 'dinner',
  'dinner_special_a': 'dinner_special_a',
  'dinner_special_b': 'dinner_special_b'
};

// Mapping database types to UI types (DB → UI)
const dbTypeToMealType = {
  'breakfast': 'breakfast',
  'lunch': 'lunch_regular',
  'lunch_box': 'lunch_box', 
  'dinner': 'dinner_regular',
  'dinner_special_a': 'dinner_special_a',
  'dinner_special_b': 'dinner_special_b'
};

const MealPlanForm = ({ 
  formData, 
  mealForm, 
  updateMealForm, 
  addMealPlan, 
  removeMealPlan,
  availableMealOptions = []
}) => {
  const [showForm, setShowForm] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [autoGeneratedMeals, setAutoGeneratedMeals] = useState([]);
  const [showAutoGenerated, setShowAutoGenerated] = useState(false);
  
  // 식사계획 자동 생성을 위한 별도 날짜 범위 상태
  const [mealDateRange, setMealDateRange] = useState({
    startDate: null,
    endDate: null
  });

  // 자동 생성용 참가자 수 상태 (수정 가능)
  const [autoGenParticipantsCount, setAutoGenParticipantsCount] = useState(0);

  // formData.participants_count가 변경될 때 autoGenParticipantsCount 업데이트
  useEffect(() => {
    setAutoGenParticipantsCount(formData.participants_count || 0);
  }, [formData.participants_count]);

  // Calculate price when participants or meal type changes
  useEffect(() => {
    // Only auto-calculate price if it hasn't been manually set
    const priceIsManuallySet = mealForm.price !== undefined && mealForm.price !== null;
    
    if (mealForm.meal_type && mealForm.participants && !priceIsManuallySet) {
      const participants = parseInt(mealForm.participants) || 0;
      const allOptions = getAllMealOptions();
      const selectedMealType = allOptions.find(type => type.value === mealForm.meal_type);
      
      if (selectedMealType) {
        const pricePerPerson = selectedMealType.price;
        const totalPrice = pricePerPerson * participants;
        
        console.log(`[MealPlanForm] Using price: ${pricePerPerson} × ${participants} = ${totalPrice}`);
        
        // Update with values
        updateMealForm('resetAll', {
          ...mealForm,
          price: totalPrice,
          price_per_person: pricePerPerson,
          meal_option: selectedMealType.meal_option || selectedMealType.label
        });
      }
    }
  }, [mealForm.meal_type, mealForm.participants, availableMealOptions, updateMealForm]);

  // Auto-generate meals based on stay period (updated to use separate meal date range)
  useEffect(() => {
    // Use separate meal date range if set, otherwise fall back to formData dates
    const startDate = mealDateRange.startDate || formData.start_date;
    const endDate = mealDateRange.endDate || formData.end_date;
    
    if (startDate && endDate) {
      const startMoment = moment(startDate);
      const endMoment = moment(endDate);
      const days = endMoment.diff(startMoment, 'days') + 1;
      
      console.log(`[MealPlanForm] Meal generation range: ${days} days`);
      
      // Generate meals for each day with all meal types (DB 옵션 사용)
      const generatedMeals = [];
      const allMealOptions = getAllMealOptions();
      
      for (let day = 0; day < days; day++) {
        const currentDate = moment(startMoment).add(day, 'days');
        
        // DB에서 가져온 모든 식사 옵션으로 자동생성 (기본적인 조식, 중식, 석식만)
        const breakfastOptions = allMealOptions.filter(opt => opt.meal_type === 'breakfast');
        const lunchOptions = allMealOptions.filter(opt => opt.meal_type === 'lunch');
        const dinnerOptions = allMealOptions.filter(opt => opt.meal_type === 'dinner');
        
        // 각 타입별로 첫 번째 옵션만 자동생성에 사용
        if (breakfastOptions.length > 0) {
          generatedMeals.push(createAutoMeal(currentDate, breakfastOptions[0], autoGenParticipantsCount));
        }
        
        if (lunchOptions.length > 0) {
          generatedMeals.push(createAutoMeal(currentDate, lunchOptions[0], autoGenParticipantsCount));
        }
        
        if (dinnerOptions.length > 0) {
          generatedMeals.push(createAutoMeal(currentDate, dinnerOptions[0], autoGenParticipantsCount));
        }
      }
      
      setAutoGeneratedMeals(generatedMeals);
    }
  }, [mealDateRange.startDate, mealDateRange.endDate, formData.start_date, formData.end_date, autoGenParticipantsCount]);

  // Helper function to create an auto-generated meal
  const createAutoMeal = (date, mealOption, participantCount) => {
    const participants = parseInt(participantCount) || 0;
    const pricePerPerson = mealOption.price;
    const totalPrice = pricePerPerson * participants;
    
    return {
      id: `temp_${mealOption.meal_type}_${mealOption.id}_${date.format('YYYYMMDD')}`,
      date: date.format('YYYY-MM-DD'),
      meal_type: mealOption.meal_type,
      meal_option: mealOption.meal_option,
      participants: participants,
      price: totalPrice,
      price_per_person: pricePerPerson,
      notes: '',
      isAutoGenerated: true
    };
  };

  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return '';
    try {
      return moment(dateString).format('YYYY-MM-DD');
    } catch (e) {
      return dateString;
    }
  };
  
  // Get meal type label - 실제 meal_option 이름을 우선 사용
  const getMealTypeLabel = (type, meal_option = null) => {
    // meal_option이 있으면 그것을 우선 사용
    if (meal_option) {
      return meal_option;
    }
    
    // First check if there's a meal type in our predefined types
    const meal = mealTypes.find(m => m.value === type);
    if (meal) return meal.label;
    
    // If not found in predefined types, use a fallback translation map
    const typeTranslations = {
      'breakfast': '조식',
      'lunch': '중식(일반)',
      'lunch_box': '도시락 중식',
      'dinner': '석식(일반)',
      'dinner_special_a': '석식(특식A)',
      'dinner_special_b': '석식(특식B)'
    };
    
    return typeTranslations[type] || type;
  };
  
  // Get meal type icon
  const getMealTypeIcon = (type) => {
    const meal = mealTypes.find(m => m.value === type);
    return meal ? meal.icon : <RestaurantIcon fontSize="small" />;
  };
  
  // Toggle form visibility
  const toggleForm = () => {
    setShowForm(!showForm);
    if (!showForm) {
      // 모든 필드를 한 번에 업데이트하여 useEffect가 여러 번 호출되는 것 방지
      // 날짜 형식을 적절히 변환하여 초기화
      const startDate = formData.start_date 
        ? (typeof formData.start_date === 'string' 
            ? new Date(formData.start_date) 
            : formData.start_date)
        : new Date();
      
      // DB 옵션에서 첫 번째 항목을 기본값으로 사용
      const allOptions = getAllMealOptions();
      const defaultMealOption = allOptions.length > 0 ? allOptions[0] : null;
      const participants = formData.participants_count || 0;
      const pricePerPerson = defaultMealOption ? defaultMealOption.price : 0;
      const totalPrice = pricePerPerson * participants;
        
      const initialFormValues = {
        date: startDate,
        meal_type: defaultMealOption ? defaultMealOption.value : '',
        participants: participants,
        price: totalPrice,
        price_per_person: pricePerPerson,
        notes: ''
      };
      
      console.log('[MealPlanForm] Initializing form with values:', initialFormValues);
      
      // 한 번의 호출로 모든 필드 업데이트
      updateMealForm('resetAll', initialFormValues);
    }
  };
  
  // Handle form field changes
  const handleFormChange = (field, value) => {
    console.log(`[MealPlanForm] Form change: ${field} = ${value}`);
    
    if (field === 'meal_type') {
      const allOptions = getAllMealOptions();
      const selectedOption = allOptions.find(type => type.value === value);
      
      if (selectedOption) {
        const participants = parseInt(mealForm.participants) || 0;
        const pricePerPerson = selectedOption.price;
        const totalPrice = pricePerPerson * participants;
        
        console.log(`[MealPlanForm] Selected meal option: ${selectedOption.label}, Price per person: ${pricePerPerson}`);
        
        updateMealForm('resetAll', {
          ...mealForm,
          meal_type: value,
          meal_option_id: selectedOption.id,
          meal_option: selectedOption.meal_option || selectedOption.label,
          price: totalPrice,
          price_per_person: pricePerPerson
        });
      } else {
        updateMealForm(field, value);
      }
    } else if (field === 'participants') {
      const participants = parseInt(value) || 0;
      const allOptions = getAllMealOptions();
      const selectedOption = allOptions.find(type => type.value === mealForm.meal_type);
      
      if (selectedOption) {
        const pricePerPerson = selectedOption.price;
        const totalPrice = pricePerPerson * participants;
        
        updateMealForm('resetAll', {
          ...mealForm,
          participants: participants,
          price: totalPrice
        });
      } else {
        updateMealForm(field, value);
      }
    } else {
      updateMealForm(field, value);
    }
  };
  
  // Handle form submission
  const handleAddClick = () => {
    // Validate required fields
    const missingFields = [];
    if (!mealForm.date) missingFields.push('날짜');
    if (!mealForm.meal_type) missingFields.push('식사 유형');
    if (!mealForm.participants) missingFields.push('인원수');
    
    if (missingFields.length > 0) {
      console.error('Missing required fields:', mealForm);
      Swal.fire({
        icon: 'warning',
        title: '필수 항목을 입력해주세요',
        text: missingFields.join(', ')
      });
      return;
    }
    
    // Make sure date is formatted properly
    let formattedDate;
    try {
      formattedDate = typeof mealForm.date === 'string' 
        ? mealForm.date 
        : moment(mealForm.date).format('YYYY-MM-DD');
    } catch (e) {
      formattedDate = moment().format('YYYY-MM-DD');
      console.error('Error formatting date:', e);
    }
    
    // Calculate price if necessary
    let pricePerPerson = parseFloat(mealForm.price_per_person) || 0;
    const participants = parseInt(mealForm.participants) || 0;
    // Use manually entered price if it's defined (including 0), otherwise calculate it
    const totalPrice = mealForm.price !== undefined && mealForm.price !== null ? parseFloat(mealForm.price) : (pricePerPerson * participants);
    
    // Get the selected meal option from DB to get the actual meal_option name
    const allOptions = getAllMealOptions();
    const selectedOption = allOptions.find(type => type.value === mealForm.meal_type);
    
    // Use the actual meal_option from DB if available
    const mealOptionName = selectedOption ? selectedOption.meal_option : '';
    
    // Extract base meal type from the composite meal_type value (e.g., "breakfast_17" -> "breakfast")
    let dbMealType = mealForm.meal_type;
    if (selectedOption && selectedOption.meal_type) {
      dbMealType = selectedOption.meal_type;
    }
    
    // Create meal plan object
    const mealPlan = {
      // Keep the original ID if in edit mode, otherwise create a new one
      id: editMode ? mealForm.id : `meal_${Date.now()}`,
      date: formattedDate,
      meal_type: dbMealType,
      meal_option: mealOptionName,  // Use the actual meal_option from DB
      participants: participants,
      price: totalPrice,
      price_per_person: pricePerPerson,
      notes: mealForm.notes || ''
    };
    
    console.log('Submitting meal plan:', mealPlan, 'Edit mode:', editMode);
    
    if (editMode) {
      // Call parent handler to update the meal plan
      addMealPlan('edit', mealPlan);
    } else {
      // Call parent handler to add a new meal plan
      addMealPlan('add', mealPlan);
    }
    
    // Reset form and close it
    resetForm();
  };
  
  // Calculate total price
  const calculateTotalPrice = (plans) => {
    if (!plans || !Array.isArray(plans)) return 0;
    return plans.reduce((total, plan) => {
      return total + (parseFloat(plan.price) || 0);
    }, 0);
  };
  
  // Handle edit functionality for meal plans
  const handleEditMealPlan = (plan) => {
    console.log('Editing meal plan:', plan);
    
    // Set each field individually to make sure all fields are updated
    updateMealForm('id', plan.id);
    
    // Handle date in different formats
    try {
      const dateObj = typeof plan.date === 'string' 
        ? new Date(plan.date) 
        : plan.date;
        
      updateMealForm('date', dateObj);
    } catch (e) {
      console.error('Error parsing date:', e);
      updateMealForm('date', new Date());
    }
    
    // Convert DB meal type to UI meal type if needed
    const uiMealType = dbTypeToMealType[plan.meal_type] || plan.meal_type;
    updateMealForm('meal_type', uiMealType);
    
    updateMealForm('participants', parseInt(plan.participants) || 0);
    updateMealForm('price', parseFloat(plan.price) || 0);
    updateMealForm('price_per_person', parseFloat(plan.price_per_person) || 0);
    updateMealForm('notes', plan.notes || '');
    
    // Open the form in edit mode
    setShowForm(true);
    setEditMode(true);
  };

  // Add a reset function that uses individual field updates and resets UI state
  const resetForm = () => {
    const allOptions = getAllMealOptions();
    const defaultMealOption = allOptions.length > 0 ? allOptions[0] : null;
    
    updateMealForm('id', null);
    updateMealForm('date', formData.start_date);
    updateMealForm('meal_type', defaultMealOption ? defaultMealOption.value : '');
    updateMealForm('participants', formData.participants_count || 0);
    updateMealForm('price', 0);
    updateMealForm('price_per_person', 0);
    updateMealForm('notes', '');
    setEditMode(false);
    setShowForm(false);
  };

  // Handle auto-generated meal plan selection
  const handleAutoGeneratedMealSelect = (meal) => {
    // Convert DB meal type to UI meal type if needed
    const uiMealType = dbTypeToMealType[meal.meal_type] || meal.meal_type;
    
    // Update the form with the auto-generated meal data
    updateMealForm('id', null); // New meal, not editing
    updateMealForm('date', new Date(meal.date));
    updateMealForm('meal_type', uiMealType);
    updateMealForm('participants', meal.participants);
    updateMealForm('price', meal.price);
    updateMealForm('price_per_person', meal.price_per_person);
    updateMealForm('notes', meal.notes);
    
    // Show the form for editing
    setShowForm(true);
    setEditMode(false);
  };
  
  // Toggle auto-generated meals visibility
  const toggleAutoGenerated = () => {
    setShowAutoGenerated(!showAutoGenerated);
  };

  // Add all auto-generated meals
  const addAllAutoGeneratedMeals = () => {
    // Validate that we have data
    if (!autoGeneratedMeals.length) {
      Swal.fire({
        icon: 'warning',
        title: '자동 생성된 식사 계획이 없습니다',
        text: '먼저 숙박 일정을 설정하세요'
      });
      return;
    }
    
    // Confirm with user
    Swal.fire({
      icon: 'question',
      title: '자동 생성된 식사 계획 추가',
      text: `${autoGeneratedMeals.length}개의 식사 계획을 추가하시겠습니까?`,
      showCancelButton: true,
      confirmButtonText: '추가',
      cancelButtonText: '취소'
    }).then((result) => {
      if (result.isConfirmed) {
        // Find which meals are already added (by date and meal type)
        const existingMeals = formData.meal_plans || [];
        const existingMealKeys = existingMeals.map(meal => 
          `${moment(meal.date).format('YYYY-MM-DD')}_${meal.meal_type}`
        );
        
        // Filter out meals that already exist
        const mealsToAdd = autoGeneratedMeals.filter(meal => {
          const key = `${meal.date}_${meal.meal_type}`;
          return !existingMealKeys.includes(key);
        });
        
        if (mealsToAdd.length === 0) {
          Swal.fire({
            icon: 'info',
            title: '추가할 식사 계획이 없습니다',
            text: '모든 식사 계획이 이미 추가되었습니다.'
          });
          return;
        }
        
        // Prepare all meals to add with unique IDs
        const preparedMeals = mealsToAdd.map((meal, index) => {
          const newMeal = {
            ...meal,
            id: `meal_${Date.now()}_${index}` // Ensure unique ID with index
          };
          delete newMeal.isAutoGenerated;
          return newMeal;
        });
        
        console.log('Adding all meals at once:', preparedMeals);
        
        // Add all meals using the new 'addAll' action
        addMealPlan('addAll', preparedMeals);
        
        Swal.fire({
          icon: 'success',
          title: '식사 계획 추가 완료',
          text: `${preparedMeals.length}개의 식사 계획이 추가되었습니다.`
        });
      }
    });
  };

  // Handle meal date range changes
  const handleMealDateRangeChange = (field, value) => {
    setMealDateRange(prev => ({
      ...prev,
      [field]: value
    }));
  };

  // Get the meal count string based on meal date range or stay duration
  const getMealCountString = () => {
    const startDate = mealDateRange.startDate || formData.start_date;
    const endDate = mealDateRange.endDate || formData.end_date;
    
    if (startDate && endDate) {
      const startMoment = moment(startDate);
      const endMoment = moment(endDate);
      const days = endMoment.diff(startMoment, 'days') + 1;
      const mealCount = days * 3; // 각 날짜마다 조식, 중식, 석식
      
      return `${days}일 (${mealCount}식)`;
    }
    return '';
  };

  // Filter meal plans that aren't already in the form data
  const getAvailableAutoMeals = () => {
    const existingMeals = formData.meal_plans || [];
    const existingMealKeys = existingMeals.map(meal => 
      `${moment(meal.date).format('YYYY-MM-DD')}_${meal.meal_type}`
    );
    
    return autoGeneratedMeals.filter(meal => {
      const key = `${meal.date}_${meal.meal_type}`;
      return !existingMealKeys.includes(key);
    });
  };

  // DB에서 가져온 옵션들만 사용 (하드코딩 제거)
  const getAllMealOptions = () => {
    console.log("=== Page3 MealPlanForm - getAllMealOptions 분석 (DB 전용) ===");
    console.log("타입확인 - DB에서 가져온 availableMealOptions:", availableMealOptions);
    
    if (!availableMealOptions || availableMealOptions.length === 0) {
      console.log("타입확인 - DB 옵션이 없음, 빈 배열 반환");
      return [];
    }
    
    const allOptions = [];
    
    availableMealOptions.forEach((option, index) => {
      console.log(`타입확인 - [${index + 1}/${availableMealOptions.length}] 처리 중인 옵션:`, option);
      
      // DB 옵션을 기존 형식에 맞게 변환
      const newOption = {
        value: `${option.meal_type}_${option.id}`, // 고유한 value 생성
        label: option.meal_option, // 입력한 이름 그대로 사용
        icon: getMealTypeIcon(option.meal_type),
        price: option.price_per_person,
        ingredient: option.ingredient_cost || 0,
        id: option.id,
        meal_type: option.meal_type,
        meal_option: option.meal_option
      };
      
      console.log("타입확인 - ✅ 옵션 추가됨:", newOption);
      allOptions.push(newOption);
    });
    
    console.log("타입확인 - 최종 모든 옵션들 (총 개수:", allOptions.length, "):", allOptions);
    console.log("=== Page3 MealPlanForm - getAllMealOptions 분석 끝 ===");
    return allOptions;
  };

  // Handle setting all meal prices to zero
  const handleSetAllMealPricesZero = () => {
    if (!formData.meal_plans || formData.meal_plans.length === 0) {
      Swal.fire({
        icon: 'warning',
        title: '식사 계획이 없습니다',
        text: '가격을 변경할 식사 계획이 없습니다.'
      });
      return;
    }

    Swal.fire({
      icon: 'question',
      title: '식사 가격 일괄 변경',
      text: `모든 식사의 가격을 0원으로 변경하시겠습니까?`,
      showCancelButton: true,
      confirmButtonText: '확인',
      cancelButtonText: '취소'
    }).then((result) => {
      if (result.isConfirmed) {
        // Update all meal prices to zero
        const updatedMeals = formData.meal_plans.map(meal => ({
          ...meal,
          price: 0,
          price_per_person: 0
        }));

        // Call the parent's addMealPlan function with 'setAllZero' action
        addMealPlan('setAllZero', updatedMeals);
        
        Swal.fire({
          icon: 'success',
          title: '가격 변경 완료',
          text: '모든 식사의 가격이 0원으로 변경되었습니다.'
        });
      }
    });
  };

  return (
    <Paper sx={{ p: 3, mb: 4 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" component="h2">
          <RestaurantIcon fontSize="small" sx={{ mr: 1, verticalAlign: 'middle' }} />
          식사 계획
        </Typography>
        <Box>
          <Button
            variant="contained"
            onClick={handleSetAllMealPricesZero}
            size="small"
            disabled={!formData.meal_plans || formData.meal_plans.length === 0}
            sx={{ 
              mr: 1,
              backgroundColor: '#000',
              color: '#fff',
              '&:hover': {
                backgroundColor: '#333',
              },
              '&:disabled': {
                backgroundColor: '#ccc',
                color: '#666',
              }
            }}
          >
            전체 0원 적용
          </Button>
          <Button
            variant="outlined"
            color="primary"
            onClick={toggleAutoGenerated}
            startIcon={<AutoAwesomeIcon />}
            size="small"
            sx={{ mr: 1 }}
          >
            {showAutoGenerated ? '자동생성 닫기' : `자동생성 ${getMealCountString()}`}
          </Button>
          <Button
            variant={showForm ? "outlined" : "contained"}
            color={showForm ? "secondary" : "primary"}
            onClick={toggleForm}
            startIcon={showForm ? <RestaurantIcon /> : <AddIcon />}
            size="small"
          >
            {showForm ? (editMode ? '수정 취소' : '식사 계획 취소') : '식사 계획 추가'}
          </Button>
        </Box>
      </Box>
      
      {showAutoGenerated && (
        <Paper variant="outlined" sx={{ p: 2, mb: 3, bgcolor: '#f5f8ff' }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="subtitle1" fontWeight="bold">
              식사 계획 자동 생성
            </Typography>
          </Box>
          
          {/* 식사 날짜 범위 설정 */}
          <Grid container spacing={2} sx={{ mb: 2 }}>
            <Grid item xs={12} sm={6} md={3}>
              <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
                <DatePicker
                  label="식사 시작일"
                  value={mealDateRange.startDate}
                  onChange={(newDate) => handleMealDateRangeChange('startDate', newDate)}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      size: 'small',
                      InputProps: {
                        startAdornment: (
                          <InputAdornment position="start">
                            <EventIcon fontSize="small" />
                          </InputAdornment>
                        )
                      }
                    }
                  }}
                />
              </LocalizationProvider>
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
                <DatePicker
                  label="식사 종료일"
                  value={mealDateRange.endDate}
                  onChange={(newDate) => handleMealDateRangeChange('endDate', newDate)}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      size: 'small',
                      InputProps: {
                        startAdornment: (
                          <InputAdornment position="start">
                            <EventIcon fontSize="small" />
                          </InputAdornment>
                        )
                      }
                    }
                  }}
                />
              </LocalizationProvider>
            </Grid>
            <Grid item xs={12} sm={6} md={2}>
              <TextField
                label="참가자 수"
                type="number"
                size="small"
                fullWidth
                value={autoGenParticipantsCount || 0}
                onChange={(e) => setAutoGenParticipantsCount(parseInt(e.target.value) || 0)}
                InputProps={{
                  endAdornment: <InputAdornment position="end">명</InputAdornment>,
                  inputProps: { min: 0 }
                }}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={4}>
              <Box sx={{ display: 'flex', gap: 1, alignItems: 'center', height: '100%' }}>
                <Button
                  variant="contained"
                  color="primary"
                  size="small"
                  onClick={addAllAutoGeneratedMeals}
                  startIcon={<AddIcon />}
                  disabled={getAvailableAutoMeals().length === 0}
                >
                  모두 추가
                </Button>
                <Typography variant="caption" color="textSecondary">
                  {getMealCountString()}
                </Typography>
              </Box>
            </Grid>
          </Grid>
          
          <Alert severity="info" sx={{ mb: 2 }}>
            식사 시작일과 종료일을 설정하면 해당 기간의 모든 날짜에 조식, 중식, 석식이 자동 생성됩니다. 
            참가자 수는 프로그램 참가자 수가 기본으로 설정됩니다.
          </Alert>
          
          {getAvailableAutoMeals().length > 0 && (
            <Grid container spacing={1}>
              {getAvailableAutoMeals().map((meal) => (
                <Grid item xs={12} sm={6} md={4} key={meal.id}>
                  <Box 
                    sx={{ 
                      p: 1.5, 
                      border: '1px solid #e0e0e0', 
                      borderRadius: 1, 
                      mb: 1, 
                      cursor: 'pointer',
                      '&:hover': {
                        bgcolor: '#f0f7ff',
                        borderColor: 'primary.main'
                      }
                    }}
                    onClick={() => handleAutoGeneratedMealSelect(meal)}
                  >
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        {getMealTypeIcon(meal.meal_type)}
                        <Typography variant="body2" sx={{ ml: 1, fontWeight: 'bold' }}>
                          {formatDate(meal.date)} {getMealTypeLabel(meal.meal_type, meal.meal_option)}
                        </Typography>
                      </Box>
                      <Chip 
                        size="small" 
                        label={`${meal.participants}명`} 
                        color="primary"
                      />
                    </Box>
                    <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 1 }}>
                      <Typography variant="caption" fontWeight="bold">
                        ₩{meal.price.toLocaleString()}
                      </Typography>
                    </Box>
                  </Box>
                </Grid>
              ))}
            </Grid>
          )}
          
          {getAvailableAutoMeals().length === 0 && (mealDateRange.startDate && mealDateRange.endDate) && (
            <Alert severity="warning">
              선택한 날짜 범위에 추가할 수 있는 식사 계획이 없습니다. 이미 모든 식사가 추가되었거나 날짜 범위를 확인해주세요.
            </Alert>
          )}
        </Paper>
      )}
      
      {showForm && (
        <Paper variant="outlined" sx={{ p: 2, mb: 3 }}>
          <Typography variant="subtitle1" gutterBottom>
            새 식사 계획 추가
          </Typography>
          
          <Grid container spacing={2}>
            <Grid item xs={12} sm={6} md={2}>
              <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
                <DatePicker
                  label="식사 날짜"
                  value={mealForm.date}
                  onChange={(newDate) => handleFormChange('date', newDate)}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      required: true,
                      InputProps: {
                        startAdornment: (
                          <InputAdornment position="start">
                            <EventIcon />
                          </InputAdornment>
                        )
                      }
                    }
                  }}
                />
              </LocalizationProvider>
            </Grid>
            <Grid item xs={12} sm={6} md={2}>
              <FormControl fullWidth required>
                <InputLabel>식사 타입</InputLabel>
                <Select
                  value={mealForm.meal_type || ''}
                  onChange={(e) => handleFormChange('meal_type', e.target.value)}
                  label="식사 타입"
                  startAdornment={
                    <InputAdornment position="start">
                      {getMealTypeIcon(mealForm.meal_type)}
                    </InputAdornment>
                  }
                >
                  {getAllMealOptions().map((type) => (
                    <MenuItem key={type.value} value={type.value}>
                      {type.icon} {type.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={6} md={2}>
              <TextField
                fullWidth
                label="참가자 수"
                type="number"
                value={mealForm.participants || ''}
                onChange={(e) => handleFormChange('participants', e.target.value)}
                required
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <PeopleIcon />
                    </InputAdornment>
                  )
                }}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={2}>
              <TextField
                fullWidth
                label="총 가격"
                type="number"
                value={mealForm.price || ''}
                onChange={(e) => handleFormChange('price', e.target.value)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      ₩
                    </InputAdornment>
                  )
                }}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <TextField
                fullWidth
                label="메모"
                value={mealForm.notes || ''}
                onChange={(e) => handleFormChange('notes', e.target.value)}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={1}>
              <Button
                variant="contained"
                color="primary"
                onClick={handleAddClick}
                sx={{ height: '100%', width: '100%' }}
                disabled={!mealForm.date || !mealForm.meal_type || !mealForm.participants}
              >
                {editMode ? <SaveIcon /> : <AddIcon />}
              </Button>
            </Grid>
          </Grid>
        </Paper>
      )}
      
      {formData.meal_plans && formData.meal_plans.length > 0 ? (
        <>
          <TableContainer>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell>날짜</TableCell>
                  <TableCell>식사 유형</TableCell>
                  <TableCell align="right">인원</TableCell>
                  <TableCell align="right">가격</TableCell>
                  <TableCell align="right">액션</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {formData.meal_plans
                  .sort((a, b) => {
                    // Sort by date first
                    const dateA = new Date(a.date);
                    const dateB = new Date(b.date);
                    const dateCompare = dateA.getTime() - dateB.getTime();
                    
                    if (dateCompare !== 0) {
                      return dateCompare;
                    }
                    
                    // If dates are the same, sort by meal type order (breakfast, lunch, dinner)
                    const mealTypeOrder = { 'breakfast': 1, 'lunch': 2, 'lunch_box': 3, 'dinner': 4, 'dinner_special_a': 5, 'dinner_special_b': 6 };
                    const orderA = mealTypeOrder[a.meal_type] || 7;
                    const orderB = mealTypeOrder[b.meal_type] || 7;
                    return orderA - orderB;
                  })
                  .map((plan, index) => (
                  <TableRow key={plan.id}>
                    <TableCell>{formatDate(plan.date)}</TableCell>
                    <TableCell>
                      {getMealTypeIcon(plan.meal_type)} {getMealTypeLabel(plan.meal_type, plan.meal_option)}
                    </TableCell>
                    <TableCell align="right">{plan.participants}명</TableCell>
                    <TableCell align="right">
                      <Tooltip title={`${plan.price_per_person ? plan.price_per_person.toLocaleString() + '원/1인' : ''}`}>
                        <Typography>₩{parseInt(plan.price).toLocaleString()}</Typography>
                      </Tooltip>
                    </TableCell>
                    <TableCell align="center">
                      <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                        <IconButton 
                          size="small" 
                          color="primary" 
                          onClick={() => handleEditMealPlan(plan)}
                          sx={{ mr: 1 }}
                        >
                          <EditIcon fontSize="small" />
                        </IconButton>
                        <IconButton 
                          size="small" 
                          color="error" 
                          onClick={() => removeMealPlan(plan.id)}
                        >
                          <DeleteIcon fontSize="small" />
                        </IconButton>
                      </Box>
                    </TableCell>
                  </TableRow>
                ))}
                <TableRow>
                  <TableCell colSpan={4} align="right">
                    <Typography variant="subtitle2">총 금액:</Typography>
                  </TableCell>
                  <TableCell align="right">
                    <TextField
                      type="text"
                      size="small"
                      value={calculateTotalPrice(formData.meal_plans).toLocaleString()}
                      onChange={(e) => {
                        // This is just a UI element for display
                        const totalValue = e.target.value !== "" ? parseFloat(e.target.value.replace(/,/g, '')) : 0;
                        console.log("Total price manually updated to:", totalValue);
                        // Additional implementation would be needed to apply this total to individual meal plans
                      }}
                      inputProps={{
                        min: 0,
                        step: 1000,
                        readOnly: true
                      }}
                      InputProps={{
                        startAdornment: <InputAdornment position="start">₩</InputAdornment>,
                        style: { textAlign: 'right', fontWeight: 'bold' }
                      }}
                      sx={{ width: '120px' }}
                    />
                  </TableCell>
                  <TableCell />
                </TableRow>
              </TableBody>
            </Table>
          </TableContainer>
        </>
      ) : (
        <Alert severity="info" sx={{ mt: 2 }}>
          등록된 식사 계획이 없습니다. '식사 계획 추가' 버튼을 클릭하여 식사 계획을 추가하세요.
        </Alert>
      )}
    </Paper>
  );
};

export default MealPlanForm; 